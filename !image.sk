options:
	variable: imagesk

import:
	java.awt.AlphaComposite
	java.awt.BasicStroke
	java.awt.Color
	java.awt.Font
	java.awt.GraphicsEnvironment
	java.awt.Image
	java.awt.Point
	java.awt.Polygon
	java.awt.RenderingHints
	java.awt.font.TextAttribute
	java.awt.geom.Line2D
	java.awt.geom.Line2D$Float as Line2DFloat
	java.awt.geom.RoundRectangle2D$Double as RoundRectangle2DFloat
	java.awt.image.BufferedImage
	java.io.ByteArrayInputStream
	java.io.ByteArrayOutputStream
	java.io.File as JavaFile
	java.lang.String
	java.net.URL
	java.text.AttributedString
	java.util.Base64
	java.util.LinkedList
	javax.imageio.ImageIO
	
	ch.njol.skript.Skript
	ch.njol.skript.lang.LiteralList
	ch.njol.skript.lang.Variable
	ch.njol.skript.lang.util.SimpleLiteral
	ch.njol.skript.util.Color as SkriptColor
	ch.njol.skript.variables.Variables
	
	org.bukkit.Bukkit

on load:
	set {{@variable}::Logger} to Bukkit.getServer().getLogger()
	set {{@variable}::Decoder} to Base64.getDecoder()
	set {{@variable}::Encoder} to Base64.getEncoder()

on unload:
	delete {{@variable}::*}

local effect [(1¦parse)] error %string%:
	trigger:
		if parse mark is 1:
			Skript.error(expression-1)
		else:
			{{@variable}::Logger}.severe("[image.sk] %expression-1%")

local effect warning %string%:
	trigger:
		{{@variable}::Logger}.warning("[image.sk] %expression-1%")

expression [(image|img)] colo[u]r (0¦%-color%|1¦[from] [hex] %-string%|2¦[from] [rgb[ ]][\(]%-number%, %-number%, %-number%[\)])[[,] [with] ((opacity|transparency) %-number% [percent]|%-number% [percent] (opacity|transparency)))]:
	get:
		if parse mark is 0 or 1:
			if parse mark is 0:
				set {_color} to expression-1.getBukkitColor()
			else:
				set {_hex} to expression-2
				replace all "##" with "" in {_hex}
				set {_color} to Color.decode("##%{_hex}%")
			set {_r} to {_color}.getRed()
			set {_g} to {_color}.getGreen()
			set {_b} to {_color}.getBlue()
		else if parse mark is 2:
			set {_r} to expression-3
			set {_g} to expression-4
			set {_b} to expression-5
		loop "r", "g" and "b":
			if {_%loop-value%} is greater than 255:
				set {_%loop-value%} to 255
			else if {_%loop-value%} is smaller than 0:
				set {_%loop-value%} to 0
		if expression-6 is set:
			set {_opacity} to expression-6
		else if expression-7 is set:
			set {_opacity} to expression-7
		set {_r} to (1 / 255) * {_r}
		set {_g} to (1 / 255) * {_g}
		set {_b} to (1 / 255) * {_b}
		if {_opacity} is set:
			set {_opacity} to (1 / 100) * {_opacity}
			if {_opacity} is greater than 1:
				set {_opacity} to 1
			else if {_opacity} is smaller than 0:
				set {_opacity} to 0
			set {_color} to new Color({_r}, {_g}, {_b} and {_opacity})
		else:
			set {_color} to new Color({_r}, {_g} and {_b})
		return {_color}

expression %color% with ((opacity|transparency) %-number% [percent]|%-number% [percent] (opacity|transparency)):
	get:
		return color expression-1 with opacity expression-2

local expression java color %object%:
	get:
		if expression-1 is instance of SkriptColor:
			return color expression-1
		return expression-1

local effect set variable %object% to %object% in %event%:
	trigger:
		set {_variable} to expression-1
		set {_name} to {_variable}.getName().toString(expression-3)
		Variables.setVariable({_name}, expression-2, expression-3, {_variable}.isLocal())

expression:
	patterns:
		(copied|cloned) [image[s]] %$objects%
		[a] (cop(y|ies)|clone[s]) of [image[s]] %$objects%
		%$objects%'[s] (cop(y|ies)|clone[s])
	get:
		loop expressions-1:
			add new BufferedImage((loop-value.getColorModel()), (loop-value.copyData(null)), (loop-value.isAlphaPremultiplied()) and null) to {_result::*}
		return {_result::*}

effect create [a[n]] [new] image with (0¦width %-number%[( and|,)] [with] height %-number%|1¦height %-number%[( and|,)] [with] width %-number%)[[( and|,)] [with] b[ack]g[round] %-object%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-6 is set:
			if expression-6 isn't instance of Variable:
				parse error "'%expression-6%' is not a variable."
				stop
		continue
	trigger:
		delay the current effect
		if parse mark is 0:
			set {_width} to rounded expression-1
			set {_height} to rounded expression-2
		else if parse mark is 1:
			set {_height} to rounded expression-3
			set {_width} to rounded expression-4
		loop "width" and "height":
			if {_%loop-value%} is smaller than 1:
				set {_%loop-value%} to 1
		set {_image} to new BufferedImage({_width}, {_height} and (BufferedImage.TYPE_INT_ARGB!))
		if java color expression-5 is instance of Color:
			set {_g} to {_image}.createGraphics()
			{_g}.setColor(java color expression-5)
			{_g}.fillRect(0, 0, {_width} and {_height})
			{_g}.dispose()
		if raw expression-6 is set:
			set variable (raw expression-6) to {_image} in event
		else:
			set {{@variable}::lastImage} to {_image}
		continue

expression [the] [last[ly]] [(created|generated|received|taken)] (image|img):
	get:
		return {{@variable}::lastImage}
	delete:
		delete {{@variable}::lastImage}

effect get [the] (image|img) (of|from) (0¦url %-string%|1¦file %-string%|2¦base[ ]64 %-string%) [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-4 is set:
			if expression-4 isn't instance of Variable:
				parse error "'%expression-4%' is not a variable."
				stop
		continue
	trigger:
		delay the current effect
		if parse mark is 0:
			if expression-1 is set:
				set {_connection} to new URL(expression-1).openConnection()
				{_connection}.setRequestProperty("User-Agent" and "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36 OPR/55.0.2994.61")
				set {_image} to ImageIO.read({_connection}.getInputStream())
		else if parse mark is 1:
			if expression-2 is set:
				set {_path} to expression-2
				replace all "/" and "\" with JavaFile.separator! in {_path}
				set {_file} to new JavaFile({_path})
				if {_file}.exists() is false:
					if expression-2 is set:
						error "'%expression-2%' is not a valid file path."
					continue
				set {_image} to ImageIO.read({_file})
		else if parse mark is 2:
			if expression-3 is set:
				set {_bytes} to {{@variable}::Decoder}.decode(last element of split expression-3 at ",")
				set {_bis} to new ByteArrayInputStream({_bytes})
				set {_image} to ImageIO.read({_bis})
				{_bis}.close()
		if {_image}.getType() is not 2:
			set {_newImage} to new BufferedImage(({_image}.getWidth()), ({_image}.getHeight()) and 2)
			set {_g} to {_newImage}.createGraphics()
			{_g}.drawImage({_image}, 0, 0, ({_image}.getWidth()), ({_image}.getHeight()) and null)
			{_g}.dispose()
			set {_image} to {_newImage}
		if raw expression-4 is set:
			set variable (raw expression-4) to {_image} in event
		else:
			set {{@variable}::lastImage} to {_image}
		continue

expression base[ ]64 encoded [(image|img)] %object% [with ([(format|file)] type|[file] format) %-string%]:
	return type: string
	get:
		if expression-1 isn't instance of BufferedImage:
			return
		if expression-2 is not set:
			set {_type} to "png"
		else:
			set {_type} to expression-2
		
		set {_bos} to new ByteArrayOutputStream()
		ImageIO.write(expression-1, {_type}, {_bos})
		set {_base64} to {{@variable}::Encoder}.encodeToString({_bos}.toByteArray())
		{_bos}.close()
		return {_base64}

effect resize [(image|img)] %object% to [sizes] (0¦width %-number%[( and|,)] height %-number%|1¦height %-number%[( and|,)] width %-number%) [(with|using) algorithm %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-7 is not set:
			if expression-1 isn't instance of Variable:
				if "%expression-1%" is not "[the] [last[ly]] [(created|generated|received|taken)] (image|img)":
					parse error "The image to be resized must be in a variable or the last image expression. Or a variable must be specified to save the result image."
					stop
		else:
			if expression-7 isn't instance of Variable:
				parse error "'%expression-7%' is not a variable."
				stop
		continue
	trigger:
		if expression-1 isn't instance of BufferedImage:
			stop
		if raw expression-7 is set:
			set {_image} to copied image expression-1
		else:
			set {_image} to expression-1
		if parse mark is 0:
			if expression-2 or expression-3 is not set:
				stop
			set {_width} to rounded expression-2
			set {_height} to rounded expression-3
		else if parse mark is 1:
			if expression-4 or expression-5 is not set:
				stop
			set {_height} to rounded expression-4
			set {_width} to rounded expression-5
		if {_width} is smaller than 1:
			set {_width} to 1
		if {_height} is smaller than 1:
			set {_height} to 1
		delay the current effect
		if expression-6 is 1:
			set {_algorithm} to Image.SCALE_AREA_AVERAGING!
		else if expression-6 is 2:
			set {_algorithm} to Image.SCALE_DEFAULT!
		else if expression-6 is 3:
			set {_algorithm} to Image.SCALE_FAST!
		else if expression-6 is 4:
			set {_algorithm} to Image.SCALE_REPLICATE!
		else if expression-6 is 5:
			set {_algorithm} to Image.SCALE_SMOOTH!
		else:
			set {_algorithm} to Image.SCALE_DEFAULT!
		set {_temp} to {_image}.getScaledInstance({_width}, {_height} and {_algorithm})
		set {_resized} to new BufferedImage({_width}, {_height} and (BufferedImage.TYPE_INT_ARGB!))
		set {_g} to {_resized}.createGraphics()
		{_g}.drawImage({_temp}, 0, 0 and null)
		{_g}.dispose()
		if raw expression-7 is not set:
			if "%raw expression-1%" is "[the] [last[ly]] [(created|generated|received|taken)] (image|img)":
				set {{@variable}::lastImage} to {_resized}
			else:
				set variable (raw expression-1) to {_resized} in event
		else:
			set variable (raw expression-7) to {_resized} in event
		continue

expression:
	patterns:
		[the] (0¦width|1¦height|2¦ascent|3¦descent) of [(image|img)] [(text|string)] %object%
		[the] [(image|img)] [(text|string)] (0¦width|1¦height|2¦ascent|3¦descent) of %object%
		[(image|img)] [(text|string)] %object%'s (0¦width|1¦height|2¦ascent|3¦descent)
		%object%'s [(image|img)] [(text|string)] (0¦width|1¦height|2¦ascent|3¦descent)
	return type: number
	parse:
		if expression-1 is instance of BufferedImage:
			if parse mark is 2 or 3:
				stop
		continue
	get:
		if expression-1 is instance of BufferedImage:
			if parse mark is 0:
				return expression-1.getWidth()
			else if parse mark is 1:
				return expression-1.getHeight()
		else if expression-1 is instance of String:
			set {_name} to expression-1
			if first 8 characters of {_name} is "imgtext:":
				set {_name} to subtext of {_name} from character 9 to length of {_name}
			if {{@variable}::texts::%{_name}%} is not set:
				return
			set {_style} to 0
			if {{@variable}::texts::%{_name}%::bold} is set:
				add Font.BOLD! to {_style}
			if {{@variable}::texts::%{_name}%::italic} is set:
				add Font.ITALIC! to {_style}
			set {_font} to new Font({{@variable}::texts::%{_name}%::font}, {_style} and {{@variable}::texts::%{_name}%::size})
			set {_g} to new BufferedImage(1, 1 and 1).getGraphics()
			set {_fm} to {_g}.getFontMetrics({_font})
			if parse mark is 0:
				return {_fm}.stringWidth({{@variable}::texts::%{_name}%::text})
			else if parse mark is 1:
				return {_fm}.getHeight()
			else if parse mark is 2:
				return {_fm}.getAscent()
			else:
				return {_fm}.getDescent()
			{_g}.dispose()

object property [colo[u]r of] pixel [at [location]] %number%( and|,) %number%:
	get:
		if expression-1 isn't instance of BufferedImage:
			return
		if expression-2 is set:
			if expression-3 is set:
				set {_x} to expression-2
				set {_y} to expression-3
				set {_rgb} to expression-1.getRGB(({_x} - 1) and ({_y} - 1))
				return new Color((bits 16-23 of {_rgb}), (bits 8-15 of {_rgb}) and (bits 0-7 of {_rgb}))
	set:
		if (java color change value) isn't instance of Color:
			stop
		if expression-2 is set:
			if expression-3 is set:
				set {_rgb} to (java color change value).getRGB()
				set {_x} to expression-2
				set {_y} to expression-3
				expression-1.setRGB(({_x} - 1), ({_y} - 1) and {_rgb})
	delete:
		if expression-2 is set:
			if expression-3 is set:
				set {_rgb} to new Color(0, 0, 0 and 0)
				set {_rgb} to {_rgb}.getRGB()
				set {_x} to expression-2
				set {_y} to expression-3
				expression-1.setRGB(({_x} - 1), ({_y} - 1) and {_rgb})

object property (opacity|transparency):
	return type: number
	get:
		if expression-1 is instance of Color:
			return expression-1.getAlpha()
		return
	set:
		if expression-1 is instance of BufferedImage:
			if (raw expression-1) is instance of Variable:
				if change value is set:
					set {_opacity} to (1 / 100) * change value
					if {_opacity} is greater than 1:
						set {_opacity} to 1
					else if {_opacity} is smaller than 0:
						set {_opacity} to 0
					set {_temp} to new BufferedImage((expression-1.getWidth()), (expression-1.getHeight()) and 2)
					set {_g} to {_temp}.createGraphics()
					{_g}.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER! and {_opacity}))
					{_g}.drawImage(expression-1, 0, 0 and null)
					{_g}.dispose()
					set variable (raw expression-1) to {_temp} in event
			else:
				error "The image to be edited must be in a variable! (set image opacity)"
		else if expression-1 is instance of Color:
			if (raw expression-1) is instance of Variable:
				if change value is set:
					set {_opacity} to change value
					set {_opacity} to (255 / 100) * {_opacity}
					if {_opacity} is greater than 255:
						set {_opacity} to 255
					else if {_opacity} is smaller than 0:
						set {_opacity} to 0
					set {_color} to new Color((expression-1.getRed()), (expression-1.getGreen()), (expression-1.getBlue()) and {_opacity})
					set variable (raw expression-1) to {_color} in event
			else:
				error "The color to be edited must be in a variable! (set color opacity)"

effect (get|extract) part of [(image|img)] %object% (0¦from [location] %-number%( and|,) %-number% to [location] %-number%( and|,) %-number%|1¦between locations %-number%( and|,) %-number% and %-number%( and|,) %-number%) [and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%:
	parse:
		if expression-10 is set:
			if expression-10) isn't instance of Variable:
				parse error "'%expression-10%' is not a variable."
				stop
		continue
	trigger:
		if expression-1 isn't instance of BufferedImage:
			stop
		delay the current effect
		if parse mark is 0:
			set {_x1} to expression-2
			set {_y1} to expression-3
			set {_x2} to expression-4
			set {_y2} to expression-5
		else if parse mark is 1:
			set {_x1} to expression-6
			set {_y1} to expression-7
			set {_x2} to expression-8
			set {_y2} to expression-9
		set {_width} to difference between {_x1} and {_x2}
		set {_height} to difference between {_y1} and {_y2}
		set variable raw expression-10 to expression-1.getSubimage(({_x1} - 1), ({_y1} - 1), ({_width} - 1) and ({_height} - 1)) in event
		continue

effect (draw|merge) [(image|img)] %object% (on|with) [(image|img)] %object% [at [location] %-number%( and|,) %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-5 is set:
			if expression-5 isn't instance of Variable:
				parse error "'%expression-5%' is not a variable."
				stop
		continue
	trigger:
		if expression-1 isn't instance of BufferedImage:
			stop
		if expression-2 isn't instance of BufferedImage:
			stop
		if expression-3 is set:
			set {_x} to expression-3
			set {_x} to {_x} - 1
		else:
			set {_x} to 0
		if expression-4 is set:
			set {_y} to expression-4
			set {_y} to {_y} - 1
		else:
			set {_y} to 0
		if raw expression-5 is set:
			set {_image} to copied image expression-2
		else:
			set {_image} to expression-2
		delay the current effect
		set {_g} to {_image}.createGraphics()
		{_g}.drawImage(expression-1, {_x}, {_y} and null)
		{_g}.dispose()
		if raw expression-5 is set:
			set variable (raw expression-5) to {_image} in event
		continue

object property condition similar to %object% [with (tolerance %-number% [percent]|%-number% [percent] tolerance)]:
	check:
		if java color expression-1 or java color expression-2 isn't instance of Color:
			stop
		if expression-3 is set:
			set {_tolerance} to expression-3
		else if expression-4 is set:
			set {_tolerance} to expression-4
		else:
			set {_tolerance} to 0
		if {_tolerance} is greater than 100:
			set {_tolerance} to 100
		else if {_tolerance} is smaller than 0:
			set {_tolerance} to 0
		set {_tolerance} to (255 / 100) * {_tolerance}
		set {_color1} to java color expression-1
		set {_color2} to java color expression-2
		set {_r1} to {_color1}.getRed()
		set {_g1} to {_color1}.getGreen()
		set {_b1} to {_color1}.getBlue()
		set {_minR} to max({_r1} - {_tolerance} and 0)
		set {_minG} to max({_g1} - {_tolerance} and 0)
		set {_minB} to max({_b1} - {_tolerance} and 0)
		set {_maxR} to min({_r1} + {_tolerance} and 255)
		set {_maxG} to min({_g1} + {_tolerance} and 255)
		set {_maxB} to min({_b1} + {_tolerance} and 255)
		if {_color2}.getRed() is between {_minR} and {_maxR}:
			if {_color2}.getGreen() is between {_minG} and {_maxG}:
				if {_color2}.getBlue() is between {_minB} and {_maxB}:
					continue

effect [(flood|bucket)] fill [on] [(image|img)] %object% (with|using) [replace[ment]] [colo[u]r] %object% at [location] %number%( and|,) %number% [with (tolerance %-number% [percent]|%-number% [percent] tolerance)] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-7 is set:
			if expression-7 isn't instance of Variable:
				parse error "'%expression-7%' is not a variable."
				stop
		continue
	trigger:
		if raw expression-7 is set:
			set {_image} to copied image expression-1
		else:
			set {_image} to expression-1
		if expression-3 or expression-4 is smaller than 0:
			stop
		if expression-3 is greater than or equal to {_image}.getWidth():
			stop
		if expression-4 is greater than or equal to {_image}.getHeight():
			stop
		set {_target} to pixel expression-3, expression-4 of {_image} 
		set {_replacement} to expression-2
		if {_target} is {_replacement}:
			stop
		if expression-5 is set:
			set {_tolerance} to expression-5
		else if expression-6 is set:
			set {_tolerance} to expression-6
		else:
			set {_tolerance} to 0
		if {_tolerance} is greater than 100:
			set {_tolerance} to 100
		else if {_tolerance} is smaller than 0:
			set {_tolerance} to 0
		set {_tolerance} to ({_tolerance} / 255) * 120
		if (pixel expression-3, expression-4 of {_image}) isn't similar to {_target} with tolerance {_tolerance}:
			stop
		delay the current effect
		set {_queue} to new LinkedList()
		{_queue}.add(new Point(expression-3 and expression-4))
		while {_queue}.isEmpty() is false:
			set {_pixel} to {_queue}.removeFirst()
			if (pixel ({_pixel}.x!) + 1, {_pixel}.y! of {_image}) is similar to {_target} with tolerance {_tolerance}:
				set pixel ({_pixel}.x!) + 1, {_pixel}.y! of {_image} to {_replacement}
				{_queue}.addLast(new Point((({_pixel}.x!) + 1) and {_pixel}.y!))
			if (pixel ({_pixel}.x!) - 1, {_pixel}.y! of {_image}) is similar to {_target} with tolerance {_tolerance}:
				set pixel ({_pixel}.x!) - 1, {_pixel}.y! of {_image} to {_replacement}
				{_queue}.addLast(new Point((({_pixel}.x!) - 1) and {_pixel}.y!))
			if (pixel {_pixel}.x!, ({_pixel}.y!) + 1 of {_image}) is similar to {_target} with tolerance {_tolerance}:
				set pixel {_pixel}.x!, ({_pixel}.y! + 1) of {_image} to {_replacement}
				{_queue}.addLast(new Point({_pixel}.x! and ({_pixel}.y! + 1)))
			if (pixel {_pixel}.x!, ({_pixel}.y!) - 1 of {_image}) is similar to {_target} with tolerance {_tolerance}:
				set pixel {_pixel}.x!, ({_pixel}.y! - 1) of {_image} to {_replacement}
				{_queue}.addLast(new Point({_pixel}.x! and ({_pixel}.y! - 1)))
		delete {_queue}
		if raw expression-7 is set:
			set variable (raw expression-7) to {_image} in event
		continue

effect:
	patterns:
		make [(image|img)] %object% rounded with arc (0¦width %-number%[( and|,)] [with] height %-number%|1¦height %-number%[( and|,)] [with] width %-number%) [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]
		round [(image|img)] %object% with arc (0¦width %-number%[( and|,)] [with] height %-number%|1¦height %-number%[( and|,)] [with] width %-number%) [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]
		make [(image|img)] %object% (circle|[fully] rounded) [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]
		[fully] round [(image|img)] %object% [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]
	parse:
		if expression-6 is set:
			if expression-6 isn't instance of Variable:
				parse error "'%expression-6%' is not a variable."
				stop
		continue
	trigger:
		if matched pattern is 1 or 2:
			if raw expression-6 is set:
				set {_image} to copied image expression-1
			else:
				set {_image} to expression-1
			if parse mark is 0:
				set {_arcWidth} to rounded expression-2
				set {_arcHeight} to rounded expression-3
			else if parse mark is 1:
				set {_arcHeight} to rounded expression-4
				set {_arcWidth} to rounded expression-5
		else:
			if raw expression-2 is set:
				set {_image} to copied image expression-1
			else:
				set {_image} to expression-1
			set {_arcWidth} to {_image}.getWidth()
			set {_arcHeight} to {_image}.getHeight()
		delay the current effect
		set {_width} to {_image}.getWidth()
		set {_height} to {_image}.getHeight()
		
		set {_output} to new BufferedImage({_width}, {_height}, (BufferedImage.TYPE_INT_ARGB!))
		set {_g} to {_output}.createGraphics()
		{_g}.setComposite(AlphaComposite.Src!)
		{_g}.setRenderingHint(RenderingHints.KEY_ANTIALIASING!, RenderingHints.VALUE_ANTIALIAS_ON!)
		{_g}.setColor(Color.WHITE!)
		{_g}.fill(new RoundRectangle2DFloat(0, 0, {_width}, {_height}, {_arcWidth}, {_arcHeight}))
		{_g}.setComposite(AlphaComposite.SrcAtop!)
		{_g}.drawImage({_image}, 0, 0, null)
		{_g}.dispose()
		if matched pattern is 1 or 2:
			if raw expression-6 is set:
				set variable (raw expression-6) to {_output} in event
				continue
		else if raw expression-2 is set:
			set variable (raw expression-2) to {_output} in event
			continue
		{_image}.setData({_output}.getData())
		continue

effect draw [a] line [(10¦with ((flat|square) (cap|edge[s])))] on [(image|img)] %object% [with width %-number%][[( and|,)] [with] [colo[u]r] %-object%] (0¦from [location] %-number%( and|,) %-number% to [location] %-number%( and|,) %-number%|1¦between locations %-number%( and|,) %-number% and %-number%( and|,) %-number%) [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-12 is set:
			if expression-12 isn't instance of Variable:
				parse error "'%expression-12%' is not a variable."
				stop
		continue
	trigger:
		if expression-1 isn't instance of BufferedImage:
			stop
		delay the current effect
		if parse mark is 0 or 10:
			set {_x1} to expression-4
			set {_y1} to expression-5
			set {_x2} to expression-6
			set {_y2} to expression-7
		else if parse mark is 1 or 11:
			set {_x1} to expression-8
			set {_y1} to expression-9
			set {_x2} to expression-10
			set {_y2} to expression-11
		if raw expression-12 is set:
			set {_image} to copied image expression-1
		else:
			set {_image} to expression-1
		set {_g} to {_image}.createGraphics()
		if expression-2 is set:
			set {_width} to expression-2
		else:
			set {_width} to 1
		if parse mark is 10 or 11:
			{_g}.setStroke(new BasicStroke({_width}))
		else:
			{_g}.setStroke(new BasicStroke({_width}, (BasicStroke.CAP_ROUND!) and 2))
		if java color expression-3 is instance of Color:
			{_g}.setColor(java color expression-3)
		{_g}.setRenderingHint((RenderingHints.KEY_ANTIALIASING!) and (RenderingHints.VALUE_ANTIALIAS_ON!))
		{_g}.draw(new Line2DFloat({_x1}, {_y1}, {_x2} and {_y2}))
		{_g}.dispose()
		if raw expression-12 is set:
			set variable (raw expression-12) to {_image} in event
		continue

effect draw [a[n]] oval [(10¦outline [with width %-number%])] on [(image|img)] %object% with (0¦(width [radius]|vertical radius) %-number%[( and|,)] [with] (height [radius]|horizontal radius) %-number%|1¦(height [radius]|horizontal radius) %-number%[( and|,)] [with] (width [radius]|vertical radius) %-number%)[[( and|,)] [with] [colo[u]r] %-object%] [at [[center] location] %-number%( and|,) %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-10 is set:
			if expression-10 isn't instance of Variable:
				parse error "'%expression-10%' is not a variable."
				stop
		continue
	trigger:
		if expression-2 isn't instance of BufferedImage:
			stop
		delay the current effect
		if expression-8 is set:
			set {_x} to expression-8
			set {_x} to {_x} - 1
		else:
			set {_x} to 0
		if expression-9 is set:
			set {_y} to expression-9
			set {_y} to {_y} - 1
		else:
			set {_y} to 0
		if parse mark is 0 or 10:
			if expression-3 or expression-4 is not set:
				continue
			set {_width} to (expression-3 * 2)
			set {_height} to (expression-4 * 2)
		else if parse mark is 1 or 11:
			if expression-5 or expression-6 is not set:
				continue
			set {_height} to (expression-5 * 2)
			set {_width} to (expression-6 * 2)
		if raw expression-10 is set:
			set {_image} to copied image expression-2
		else:
			set {_image} to expression-2
		set {_g} to {_image}.createGraphics()
		if java color expression-7 is instance of Color:
			{_g}.setColor(java color expression-7)
		{_g}.setRenderingHint((RenderingHints.KEY_ANTIALIASING!) and (RenderingHints.VALUE_ANTIALIAS_ON!))
		if parse mark is 10 or 11:
			if expression-1 is set:
				set {_outlineWidth} to expression-1
			else:
				set {_outlineWidth} to 1
			{_g}.setStroke(new BasicStroke({_outlineWidth}, (BasicStroke.CAP_ROUND!) and 2))
			{_g}.drawOval(({_x} - ({_width} / 2)), ({_y} - ({_height} / 2)), {_width} and {_height})
		else:
			{_g}.fillOval(({_x} - ({_width} / 2)), ({_y} - ({_height} / 2)), {_width} and {_height})
		{_g}.dispose()
		if raw expression-10 is set:
			set variable (raw expression-10) to {_image} in event
		continue

effect draw [a[n]] circle [(1¦outline [with width %-number%])] on [(image|img)] %object% with (radius|width|height) %number%[[( and|,)] [with] [colo[u]r] %-object%] [at [[center] location] %-number%( and|,) %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-7 is set:
			if expression-7 isn't instance of Variable:
				parse error "'%expression-7%' is not a variable."
				stop
		continue
	trigger:
		if expression-2 isn't instance of BufferedImage:
			stop
		delay the current effect
		if expression-5 is set:
			set {_x} to expression-5
			set {_x} to {_x} - 1
		else:
			set {_x} to 0
		if expression-6 is set:
			set {_y} to expression-6
			set {_y} to {_y} - 1
		else:
			set {_y} to 0
		if raw expression-7 is set:
			set {_image} to copied image expression-2
		else:
			set {_image} to expression-2
		set {_g} to {_image}.createGraphics()
		if java color expression-4 is instance of Color:
			{_g}.setColor(java color expression-4)
		{_g}.setRenderingHint((RenderingHints.KEY_ANTIALIASING!) and (RenderingHints.VALUE_ANTIALIAS_ON!))
		if parse mark is 1:
			if expression-1 is set:
				set {_outlineWidth} to expression-1
			else:
				set {_outlineWidth} to 1
			{_g}.setStroke(new BasicStroke({_outlineWidth}, (BasicStroke.CAP_ROUND!) and 2))
			{_g}.drawOval(({_x} - expression-3), ({_y} - expression-3), (expression-3 * 2) and (expression-3 * 2))
		else:
			{_g}.fillOval(({_x} - expression-3), ({_y} - expression-3), (expression-3 * 2) and (expression-3 * 2))
		{_g}.dispose()
		if raw expression-7 is set:
			set variable (raw expression-7) to {_image} in event
		continue

effect draw [a] polygon [(1¦outline [(2¦with ((flat|square) (cap|(edge|corner)[s])))] [with width %-number%])][[( and|,)] with [colo[u]r] %-object%] on [(image|img)] %object% ((between|at)|using) ((corners|vertices|vertexes|points)|[(corner|vertice|vertex|point)] locations) %numbers% [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-5 is set:
			if expression-5 isn't instance of Variable:
				parse error "'%expression-5%' is not a variable."
				stop
		if expression-4 is instance of SimpleLiteral or LiteralList:
			set {_list::*} to ...(expression-4).getArray()
			set {_vertices} to rounded down (size of {_list::*}) / 2
			if {_vertices} is smaller than 3:
				parse error "A polygon must have 3 or more vertices! But entered only %{_vertices}% vertice locations."
				stop
		continue
	trigger:
		if expression-3 isn't instance of BufferedImage:
			stop
		if (size of expressions-4) / 2 is smaller than 3:
			error "A polygon must have 3 or more vertices! But entered %rounded down (size of expressions-4) / 2% vertice locations."
			stop
		delay the current effect
		if raw expression-5 is set:
			set {_image} to copied image expression-3
		else:
			set {_image} to expression-3
		set {_g} to {_image}.createGraphics()
		if java color expression-2 is instance of Color:
			{_g}.setColor(java color expression-2)
		{_g}.setRenderingHint((RenderingHints.KEY_ANTIALIASING!) and (RenderingHints.VALUE_ANTIALIAS_ON!))
		set {_polygon} to new Polygon()
		loop expressions-4:
			add 1 to {_coord}
			set {_c} to loop-value
			add {_c} - 1 to {_coords::*}
			if mod({_coord}, 2) is 0:
				{_polygon}.addPoint({_coords::*})
				delete {_coords::*}
		if parse mark is 1 or 3:
			if expression-1 is set:
				set {_outlineWidth} to expression-1
			else:
				set {_outlineWidth} to 1
			if parse mark is 1:
				{_g}.setStroke(new BasicStroke({_outlineWidth}, (BasicStroke.CAP_ROUND!) and 1))
			else:
				{_g}.setStroke(new BasicStroke({_outlineWidth}))
			{_g}.drawPolygon({_polygon})
		else:
			{_g}.fillPolygon({_polygon})
		{_g}.dispose()
		if raw expression-5 is set:
			set variable (raw expression-5) to {_image} in event
		continue

effect draw [a] polygon [(1¦outline [(2¦with ((flat|square) (cap|(edge|corner)[s])))] [with width %-number%])][[( and|,)] with [colo[u]r] %-object%] on [(image|img)] %object% (with|using) %number% [of] (corners|vertices|vertexes|points) with radius %number%[( and|,) [with] angle %-number%] [at [[center] location] %-number%( and|,) %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-9 is set:
			if expression-9 isn't instance of Variable:
				parse error "'%expression-9%' is not a variable."
				stop
		continue
	trigger:
		if expression-3 isn't instance of BufferedImage:
			stop
		delay the current effect
		if raw expression-9 is set:
			set {_image} to copied image expression-3
		else:
			set {_image} to expression-3
		set {_g} to {_image}.createGraphics()
		if java color expression-2 is instance of Color:
			{_g}.setColor(java color expression-2)
		{_g}.setRenderingHint((RenderingHints.KEY_ANTIALIASING!) and (RenderingHints.VALUE_ANTIALIAS_ON!))
		if expression-4 is smaller than 3:
			error "A polygon must have 3 or more vertices! But entered %expression-4% vertice locations."
			continue
		if expression-6 is set:
			set {_angle} to expression-6
		else:
			set {_angle} to 180
		if expression-7 is set:
			set {_x} to expression-7
			set {_x} to {_x} - 1
		else:
			set {_x} to 0
		if expression-8 is set:
			set {_y} to expression-8
			set {_y} to {_y} - 1
		else:
			set {_y} to 0
		# Algorithm by bi0qaw (https://github.com/bi0qaw)
		set {_angleChange} to 360 / expression-4
		set {_polygon} to new Polygon()
		loop expression-4 times:
			{_polygon}.addPoint(({_x} + expression-5 * sin({_angle})) and ({_y} + expression-5 * cos({_angle})))
			add {_angleChange} to {_angle}
		if parse mark is 1 or 3:
			if expression-1 is set:
				set {_outlineWidth} to expression-1
			else:
				set {_outlineWidth} to 1
			if parse mark is 1:
				{_g}.setStroke(new BasicStroke({_outlineWidth}, (BasicStroke.CAP_ROUND!) and 1))
			else:
				{_g}.setStroke(new BasicStroke({_outlineWidth}))
			{_g}.drawPolygon({_polygon})
		else:
			{_g}.fillPolygon({_polygon})
		{_g}.dispose()
		if raw expression-9 is set:
			set variable (raw expression-9) to {_image} in event
		continue

effect draw [a] rectangle [(2¦outline [with width %-number%])] with (0¦width %-number%[( and|,)] [with] height %-number%|1¦height %-number%[( and|,)] [with] width %-number%)[[( and|,)] with [colo[u]r] %-object%] on [(image|img)] %object% [at [location] %-number%( and|,) %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-10 is set:
			if expression-10 isn't instance of Variable:
				parse error "'%expression-10%' is not a variable."
				stop
		continue
	trigger:
		if expression-7 isn't instance of BufferedImage:
			stop
		delay the current effect
		if parse mark is 0 or 2:
			set {_width} to rounded expression-2
			set {_height} to rounded expression-3
		else if parse mark is 1 or 3:
			set {_height} to rounded expression-4
			set {_width} to rounded expression-5
		if expression-8 is set:
			set {_x} to expression-8
			set {_x} to {_x} - 1
		else:
			set {_x} to 0
		if expression-9 is set:
			set {_y} to expression-9
			set {_y} to {_y} - 1
		else:
			set {_y} to 0
		if raw expression-10 is set:
			set {_image} to copied image expression-7
		else:
			set {_image} to expression-7
		set {_g} to {_image}.createGraphics()
		if java color expression-6 is instance of Color:
			{_g}.setColor(java color expression-6)
		{_g}.setRenderingHint((RenderingHints.KEY_ANTIALIASING!) and (RenderingHints.VALUE_ANTIALIAS_ON!))
		if parse mark is 2 or 3:
			if expression-1 is set:
				set {_outlineWidth} to expression-1
			else:
				set {_outlineWidth} to 1
			{_g}.setStroke(new BasicStroke({_outlineWidth}))
			{_g}.drawRect({_x}, {_y}, {_width} and {_height})
		else:
			{_g}.fillRect({_x}, {_y}, {_width} and {_height})
		{_g}.dispose()
		if raw expression-10 is set:
			set variable (raw expression-10) to {_image} in event
		continue

effect:
	patterns:
		draw [a] rounded rectangle [(2¦outline [with width %-number%])] with arc (0¦width %-number%[( and|,)] [with] height %-number%|1¦height %-number%[( and|,)] [with] width %-number%) with [rectangle] width %-number%[( and|,)] [with] height %-number%[[( and|,)] with [colo[u]r] %-object%] on [(image|img)] %object% [at [location] %-number%( and|,) %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]
		draw [a] rounded rectangle [(2¦outline [with width %-number%])] with arc height %-number%[( and|,)] [with] width %-number% with [rectangle] (0¦width %-number%[( and|,)] [with] height %-number%|1¦height %-number%[( and|,)] [with] width %-number%)[[( and|,)] with [colo[u]r] %-object%] on [(image|img)] %object% [at [location] %-number%( and|,) %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]
	parse:
		if expression-12 is set:
			if expression-12 isn't instance of Variable:
				parse error "'%expression-12%' is not a variable."
				stop
		continue
	trigger:
		if expression-9 isn't instance of BufferedImage:
			stop
		delay the current effect
		if matched pattern is 1:
			if parse mark is 0 or 2:
				set {_arcWidth} to rounded expression-2
				set {_arcHeight} to rounded expression-3
			else if parse mark is 1 or 3:
				set {_arcHeight} to rounded expression-4
				set {_arcWidth} to rounded expression-5
			set {_width} to rounded expression-6
			set {_height} to rounded expression-7
		else:
			set {_arcWidth} to rounded expression-2
			set {_arcHeight} to rounded expression-3
			if parse mark is 0 or 2:
				set {_width} to rounded expression-6
				set {_height} to rounded expression-7
			else if parse mark is 3:
				set {_height} to rounded expression-8
				set {_width} to rounded expression-9
		if expression-10 is set:
			set {_x} to expression-10
			set {_x} to {_x} - 1
		else:
			set {_x} to 0
		if expression-11 is set:
			set {_y} to expression-11
			set {_y} to {_y} - 1
		else:
			set {_y} to 0
		if raw expression-12 is set:
			set {_image} to copied image expression-9
		else:
			set {_image} to expression-9
		set {_g} to {_image}.createGraphics()
		if java color expression-8 is instance of Color:
			{_g}.setColor(java color expression-8)
		{_g}.setRenderingHint((RenderingHints.KEY_ANTIALIASING!) and (RenderingHints.VALUE_ANTIALIAS_ON!))
		if parse mark is 2 or 3:
			if expression-1 is set:
				set {_outlineWidth} to expression-1
			else:
				set {_outlineWidth} to 1
			{_g}.setStroke(new BasicStroke({_outlineWidth}))
			{_g}.drawRoundRect({_x}, {_y}, {_width}, {_height}, {_arcWidth} and {_arcHeight})
		else:
			{_g}.fillRoundRect({_x}, {_y}, {_width}, {_height}, {_arcWidth} and {_arcHeight})
		{_g}.dispose()
		if raw expression-12 is set:
			set variable (raw expression-12) to {_image} in event
		continue

effect (create|generate) [a[n]] [new] [(image|img)] (text|string) [(with (id|name)|named)] %string% [[and] with text %-string%]:
	trigger:
		if {{@variable}::texts::%expression-1%} is set:
			delete {{@variable}::texts::%expression-1%::*}
		set {{@variable}::texts::%expression-1%} to true
		if expression-2 is set:
			set {{@variable}::texts::%expression-1%::text} to expression-2
		set {{@variable}::texts::%expression-1%::font} to Font.DIALOG!
		set {{@variable}::texts::%expression-1%::size} to 12
		set {{@variable}::texts::%expression-1%::foreground} to color "FFFFFF"

expression [the] (image|img) (text|string) [(with (id|name)|named)] %string%:
	return type: string
	get:
		if {{@variable}::texts::%expression-1%} is set:
			return "imgtext:%expression-1%"
		else:
			return
	delete:
		delete {{@variable}::texts::%expression-1%} and {{@variable}::texts::%expression-1%::*}

expression [(all [[of] the]|the)] (image|img) (text|string)s:
	return type: strings
	get:
		loop {{@variable}::texts::*}:
			add "imgtext:%loop-index%" to {_list::*}
		return {_list::*}
	delete:
		delete {{@variable}::texts::*}
 
expression (0¦(text|string)|1¦font[[( |-)]family]) of [[(image|img)] (text|string)] %string%:
	return type: string
	get:
		if parse mark is 0:
			return {{@variable}::texts::%expression-1%::text}
		else if parse mark is 1:
			return {{@variable}::texts::%expression-1%::font}
	set:
		if {{@variable}::texts::%expression-1%} is set:
			if parse mark is 0:
				if change value is instance of String:
					set {{@variable}::texts::%expression-1%::text} to change value
			else if parse mark is 1:
				if change value is instance of String:
					set {{@variable}::texts::%expression-1%::font} to change value
	reset:
		if parse mark is 0:
			set {{@variable}::texts::%expression-1%::text} to "Sample Text"
		else if parse mark is 1:
			set {{@variable}::texts::%expression-1%::font} to Font.DIALOG!

expression (0¦bold|1¦italic|2¦underline[d]|3¦strikethrough|4¦outline[d]|5¦(only|just) outline) [state] of [[(image|img)] (text|string)] %string%:
	return type: boolean
	get:
		if parse mark is 0:
			return {{@variable}::texts::%expression-1%::bold}
		else if parse mark is 1:
			return {{@variable}::texts::%expression-1%::italic}
		else if parse mark is 2:
			return {{@variable}::texts::%expression-1%::underline}
		else if parse mark is 3:
			return {{@variable}::texts::%expression-1%::strikethrough}
		else if parse mark is 4:
			return {{@variable}::texts::%expression-1%::outline}
		else if parse mark is 5:
			return {{@variable}::texts::%expression-1%::onlyOutline}
	set:
		if {{@variable}::texts::%expression-1%} is set:
			if change value is true or false:
				if parse mark is 0:
					if change value is true:
						set {{@variable}::texts::%expression-1%::bold} to true
					else:
						delete {{@variable}::texts::%expression-1%::bold}
				else if parse mark is 1:
					if change value is true:
						set {{@variable}::texts::%expression-1%::italic} to true
					else:
						delete {{@variable}::texts::%expression-1%::italic}
				else if parse mark is 2:
					if change value is true:
						set {{@variable}::texts::%expression-1%::underline} to true
					else:
						delete {{@variable}::texts::%expression-1%::underline}
				else if parse mark is 3:
					if change value is true:
						set {{@variable}::texts::%expression-1%::strikethrough} to true
					else:
						delete {{@variable}::texts::%expression-1%::strikethrough}
				else if parse mark is 4:
					if change value is true:
						set {{@variable}::texts::%expression-1%::outline} to true
					else:
						delete {{@variable}::texts::%expression-1%::outline}
				else if parse mark is 5:
					if change value is true:
						set {{@variable}::texts::%expression-1%::onlyOutline} to true
					else:
						delete {{@variable}::texts::%expression-1%::onlyOutline}
	reset:
		if parse mark is 0:
			delete {{@variable}::texts::%expression-1%::bold}
		else if parse mark is 1:
			delete {{@variable}::texts::%expression-1%::italic}
		else if parse mark is 2:
			delete {{@variable}::texts::%expression-1%::underline}
		else if parse mark is 3:
			delete {{@variable}::texts::%expression-1%::strikethrough}
		else if parse mark is 4:
			delete {{@variable}::texts::%expression-1%::outline}
		else if parse mark is 5:
			delete {{@variable}::texts::%expression-1%::onlyOutline}

expression size of [[(image|img)] (text|string)] %string%:
	return type: number
	get:
		return {{@variable}::texts::%expression-1%::size}
	set:
		if "%change value%" parsed as number is set:
			set {{@variable}::texts::%expression-1%::size} to change value
	add:
		if "%change value%" parsed as number is set:
			add change value to {{@variable}::texts::%expression-1%::size}
	remove:
		if "%change value%" parsed as number is set:
			remove change value from {{@variable}::texts::%expression-1%::size}
	reset:
		set {{@variable}::texts::%expression-1%::size} to 12

expression outline (width|size) of [[(image|img)] (text|string)] %string%:
	return type: number
	get:
		if {{@variable}::texts::%expression-1%::outlineWidth} is set:
			return {{@variable}::texts::%expression-1%::outlineWidth}
		else:
			return 1
	set:
		if "%change value%" parsed as number is set:
			set {{@variable}::texts::%expression-1%::outlineWidth} to change value
	add:
		if "%change value%" parsed as number is set:
			add change value to {{@variable}::texts::%expression-1%::outlineWidth}
	remove:
		if "%change value%" parsed as number is set:
			remove change value from {{@variable}::texts::%expression-1%::outlineWidth}
	reset:
		delete {{@variable}::texts::%expression-1%::outlineWidth}
	delete:
		delete {{@variable}::texts::%expression-1%::outlineWidth}

expression (0¦[foreground]|1¦background|2¦outline) colo[u]r of [[(image|img)] (text|string)] %string%:
	get:
		if parse mark is 0:
			return {{@variable}::texts::%expression-1%::foreground}
		else if parse mark is 1:
			return {{@variable}::texts::%expression-1%::background}
		else if parse mark is 2:
			if {{@variable}::texts::%expression-1%::outlineColor} is set:
				return {{@variable}::texts::%expression-1%::outlineColor}
			else:
				return color hex "000000"
	set:
		if java color change value is instance of Color:
			if parse mark is 0:
				set {{@variable}::texts::%expression-1%::foreground} to java color change value
			else if parse mark is 1:
				set {{@variable}::texts::%expression-1%::background} to java color change value
			else if parse mark is 2:
				set {{@variable}::texts::%expression-1%::outlineColor} to java color change value
	reset:
		if parse mark is 0:
			delete {{@variable}::texts::%expression-1%::foreground}
		else if parse mark is 1:
			delete {{@variable}::texts::%expression-1%::background}
		else if parse mark is 2:
			delete {{@variable}::texts::%expression-1%::outlineColor}
	delete:
		if parse mark is 0:
			delete {{@variable}::texts::%expression-1%::foreground}
		else if parse mark is 1:
			delete {{@variable}::texts::%expression-1%::background}
		else if parse mark is 2:
			delete {{@variable}::texts::%expression-1%::outlineColor}

effect (write|draw) [[(image|img)] (text|string) [(with (id|name)|named)]] %string% (on|to) [(image|img)] %object% [at [location] %-number%( and|,) %-number%] [[and] (store|save) ([[the] result]|it) (in|to) [variable] %-object%]:
	parse:
		if expression-5 is set:
			if expression-5 isn't instance of Variable:
				parse error "'%expression-5%' is not a variable."
				stop
		continue
	trigger:
		if expression-2 isn't instance of BufferedImage:
			stop
		if {{@variable}::texts::%expression-1%} is not set:
			stop
		delay the current effect
		if raw expression-5 is set:
			set {_image} to copied image expression-2
		else:
			set {_image} to expression-2
		set {_g} to {_image}.createGraphics()
		set {_font} to {{@variable}::texts::%expression-1%::font}
		set {_size} to {{@variable}::texts::%expression-1%::size}
		if {_size} is smaller than 1:
			set {_size} to 1
		set {_text} to {{@variable}::texts::%expression-1%::text}
		set {_style} to 0
		if {{@variable}::texts::%expression-1%::bold} is set:
			add Font.BOLD! to {_style}
		if {{@variable}::texts::%expression-1%::italic} is set:
			add Font.ITALIC! to {_style}
		set {_font} to new Font({_font}, {_style} and {_size})
		{_g}.setFont({_font})
		if expression-3 is set:
			set {_x} to expression-3
			set {_x} to {_x} - 1
		else:
			set {_x} to 0
		if expression-4 is set:
			set {_y} to expression-4
			add {_g}.getFontMetrics({_font}).getAscent() - 1 to {_y}
		else:
			set {_y} to {_g}.getFontMetrics({_font}).getAscent() - 1
		{_g}.setRenderingHint((RenderingHints.KEY_ANTIALIASING!) and (RenderingHints.VALUE_ANTIALIAS_ON!))
		if {{@variable}::texts::%expression-1%::outline}, {{@variable}::texts::%expression-1%::onlyOutline}, {{@variable}::texts::%expression-1%::outlineColor} or {{@variable}::texts::%expression-1%::outlineWidth} is set:
			loop ...{_text}.split("\n|\\n"):
				set {_w} to loop-value
				if {{@variable}::texts::%expression-1%::underline}, {{@variable}::texts::%expression-1%::strikethrough} or {{@variable}::texts::%expression-1%::background} is set:
					warning "Using underline, strikethrough and background color with outline in the same time isn't supported currently. These properties won't work."
				set {_frc} to {_g}.getFontRenderContext()
				set {_gv} to {_font}.createGlyphVector({_frc} and {_w})
				if {{@variable}::texts::%expression-1%::outlineWidth} is set:
					{_g}.setStroke(new BasicStroke({{@variable}::texts::%expression-1%::outlineWidth}, (BasicStroke.CAP_ROUND!) and 1))
				if {{@variable}::texts::%expression-1%::onlyOutline} is not set:
					if {{@variable}::texts::%expression-1%::foreground} is set:
						{_g}.setColor({{@variable}::texts::%expression-1%::foreground})
					{_g}.fill({_gv}.getOutline({_x} and {_y}))
				if {{@variable}::texts::%expression-1%::outlineColor} is set:
					{_g}.setColor({{@variable}::texts::%expression-1%::outlineColor})
				else:
					{_g}.setColor(color hex "000000")
				{_g}.draw({_gv}.getOutline({_x} and {_y}))
				add {_g}.getFontMetrics({_font}).getHeight() to {_y}
		else:
			loop ...{_text}.split("\n|\\n"):
				set {_w} to loop-value
				if {{@variable}::texts::%expression-1%::underline}, {{@variable}::texts::%expression-1%::strikethrough}, {{@variable}::texts::%expression-1%::foreground} or {{@variable}::texts::%expression-1%::background} is set:
					set {_aString} to new AttributedString({_w})
					if {{@variable}::texts::%expression-1%::underline} is set:
						{_aString}.addAttribute((TextAttribute.UNDERLINE!) and (TextAttribute.UNDERLINE_ON!))
					if {{@variable}::texts::%expression-1%::strikethrough} is set:
						{_aString}.addAttribute((TextAttribute.STRIKETHROUGH!) and (TextAttribute.STRIKETHROUGH_ON!))
					if {{@variable}::texts::%expression-1%::foreground} is set:
						{_aString}.addAttribute((TextAttribute.FOREGROUND!) and {{@variable}::texts::%expression-1%::foreground})
					if {{@variable}::texts::%expression-1%::background} is set:
						{_aString}.addAttribute((TextAttribute.BACKGROUND!) and {{@variable}::texts::%expression-1%::background})
					{_aString}.addAttribute((TextAttribute.FONT!) and {_font})
					set {_w} to {_aString}.getIterator()
				{_g}.drawString({_w}, {_x} and {_y})
				add {_g}.getFontMetrics({_font}).getHeight() - 2 to {_y}
		{_g}.dispose()
		if raw expression-5 is set:
			set variable (raw expression-5) to {_image} in event
		continue

effect (save|write) [(image|img)] %object% to [file] %string%:
	trigger:
		if expression-1 isn't instance of BufferedImage:
			stop
		delay the current effect
		set {_path} to expression-2
		replace all "/" and "\" with JavaFile.separator! in {_path}
		set {_file} to new JavaFile({_path})
		{_file}.mkdirs()
		set {_fileName} to last element of split {_path} at JavaFile.separator!
		if {_fileName} contains ".":
			set {_extension} to last element of split {_fileName} at "."
		else:
			set {_extension} to "png"
		ImageIO.write(expression-1, {_extension} and {_file})
		continue

effect (register|install|load) [(the|new)] font [family] [(from|of|at))] [[the] file] %string%:
	trigger:
		delay the current effect
		if expression-1 is set:
			set {_path} to expression-1
			replace all "/" and "\" with JavaFile.separator! in {_path}
			set {_file} to new JavaFile({_path})
			if {_file}.exists() is false:
				if expression-1 is set:
					error "'%expression-1%' is not a valid file path."
				continue
			GraphicsEnvironment.getLocalGraphicsEnvironment().registerFont(Font.createFont(Font.TRUETYPE_FONT! and {_file}))
		continue

expression:
	patterns:
		[(all [[of] the]|the)] [available] fonts
		[(all [[of] the]|the)] [available] font (families|[family] names)
	return type: strings
	get:
		return ...GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames()
